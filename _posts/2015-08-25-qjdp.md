---
layout: post
title: 区间DP小结
description: 坚持就是胜利，量变引发质变。
key: blog
---

### 前言

前段时间做了暑假的多校，期间遇到了几个区间DP，前段时间又做了几场regional的题目，发现区间dp这个东西真的出现的很频繁，决定刷一刷总结一下。

### 引入

区间DP是动态规划的一种，问题可以抽象成在一条数轴上的问题，而区间的包含关系就等价于重叠子结构的问题。

### 经典问题1：

石子合并问题： 共有N堆石子，每堆石子有一个数量，可以合并相邻的两堆石子，合并的代价是两堆石子的数量总和，求最小代价。

分析：由于合并顺序的不确定，从第i堆石子合并到第j堆石子的代价是不确定的，但是最后一次合并的代价是知道的。

这样的话不难发现状态可以设为dp[i][j]，表示从第i堆石子合并到第j堆石子所花费代价的最小值。

有了状态，状态转移方程就不难发现：dp[i][j] = min{ dp[i][k] + dp[k+1][j] + sum{i,j} }。

* 这个模型很明显符合四边形不等式优化的条件，所以如果用四边形不等式优化的话，时间复杂度可以降到N^2级别的。

### 经典问题2：

括号匹配问题：给出一个由'(',')','[',']','{','}'组成的序列，求出这个串的最长子序列使得这个子序列符合括号匹配标准。

分析：这个问题也是典型的可以抽象在数轴上的问题，对于i到j这个区间，如果在区间里边有一个符号跟i匹配，那么答案就可能是i+1到k-1和k+1到j这两段的和。

有了这个想法，就可以设状态dp[i][j]，表示i到j的最大匹配序列长度。

方程为：dp[i][j] = max{ dp[i+1][k-1] + dp[k+1][j] + 2 (s[i]和s[k]匹配) }。

### 经典问题3：

三角形分割：给出一个多边形，给出划分三角形的代价，求出把这个多边形分成三角形的最小代价。

分析：由于多边形，对角线任意，所以连接一条对角线之后的图形也是任意的，很难表示，所以用区间规范它。

方程：dp[i][j]，表示从第i个点到第j个点，划分成三角形的最小代价。

转移的过程就是在区间内枚举点k，将i,j,k连接，形成三角形，然后划分成子问题解决。

### Light oj 1422：

给出n天穿着的衣服样式，可以不停地穿，但是脱掉的衣服不能再穿，至少需要多少衣服可以满足穿着需要。

分析：问题依然明显，由于脱掉的衣服不能再穿，那么对于第i天到第j天这段时间，如果有一天k，穿着跟第i天相等，那么答案就可以分为i+1到k-1和k+1到j这两段。

状态：dp[i][j]，表示第i天到第j天最少需要多少套衣服。

转移方程：dp[i][j] = min{ dp[i+1][k-1] + dp[k+1][j] + 1 (a[i] == a[k]) }

### HDU 4053：

给出n个开关，开关之间有距离，每个开关再按下去之后经过一段时间会再弹起，问有没有一种按开关的顺序可以使得开关处于按下的状态。

分析：首先可以考虑这样一个问题，对于这个人从第i个开关走到第j个开关的过程中，这些个开关是可以在走的过程中全部按下去的，也就是说对于任意k(i < k < j)，没有必要先按下k再回去从i按到j。

考虑完这个问题之后就可以发现，这个问题也是一个区间动态规划的问题。

状态：dp[i][j][f],表示第i个开关按到第j个开关，之后停留在i这个点或j这个点所需要的最小时间。(p = 1 或 p = 0)。

状态转移：对于i到j枚举中间点k，计算代价，去最小值。

### DLUT OJ 1312

给出n个数字，每次从其中取走一个，代价为这个数和两边数字的乘积，一直取到最后只剩两个数字求最小代价。

分析：这个问题看上去也是抽象在数轴上的问题，但是有一个小技巧，就是设计状态的小技巧。

状态：dp[i][j]，表示i到j这个区间全部取完所花费的最小代价。

状态转移：转移的时候必然要枚举区间中的点k，表示i到j区间最后取走k这个数字，所花费的代价。(这就是设计上的小技巧，你想到了吗？)

### POJ 3280

给出一个字符串，和每一个字符删除和添加的花费，求把这个字符串变成回文串的最小花费。

分析：对于这个字符串，我们考虑i到j这个区间，对于这个区间，把它们变成字符串分成三种情况：

* s[i] == s[j]，这样的话，代价等于i+1到j-1的代价

* 把i+1到j这一段变成回文串，删除s[i]或添加一个s[i]

* 把i到j-1这一段变成回文串，删除s[j]或添加一个s[j]

三种情况去最小值即可。

状态：dp[i][j]，表示从字符串i到j区间变成回文串的最小代价。

### HDU 2476

给出两个字符串，要将第一个变成第二个，每次可以将一个区间的字符变成一个，问最少需要操作多少次。

分析：还是区间DP，也不是很难想，只是有几个点需要注意，在计算完动态规划的结果的时候，dp[1][n]不一定就是最佳答案，需要枚举每一段起点和终点取最小值，因为两个字符串之间会有一些相同的字符，可能不需要操作。

### ZOJ 3537

给出一个蛋糕，将它分成三角形，求最小代价。

分析：这个题先求一下凸包判断一下可行性，然后剩下的就是经典模型三角形分割了。

